import * as i0 from '@angular/core';
import { Injectable, Directive, Input, NgModule, createComponent, TemplateRef, Component, InjectionToken, inject, Injector, ApplicationRef, EnvironmentInjector, signal } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { filter, map } from 'rxjs/operators';

class TeleportService {
    constructor() {
        this.outlets = new BehaviorSubject('');
        this.asObservable = this.outlets.asObservable();
        this.ports = new Map();
    }
    outlet$(name) {
        return this.asObservable.pipe(filter(current => current === name), map(name => this.ports.get(name)));
    }
    newOutlet(name) {
        this.outlets.next(name);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: TeleportService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: TeleportService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: TeleportService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class TeleportOutletDirective {
    constructor(vcr, service) {
        this.vcr = vcr;
        this.service = service;
    }
    ngOnChanges(changes) {
        // The `teleportOutlet` might be `null|undefined`, but we don't want nullable values to be used
        // as keys for the `ports` map.
        if (changes.teleportOutlet && typeof this.teleportOutlet === 'string') {
            this.service.ports.set(this.teleportOutlet, this.vcr);
            this.service.newOutlet(this.teleportOutlet);
        }
    }
    ngOnDestroy() {
        this.service.ports.delete(this.teleportOutlet);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: TeleportOutletDirective, deps: [{ token: i0.ViewContainerRef }, { token: TeleportService }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.3", type: TeleportOutletDirective, selector: "[teleportOutlet]", inputs: { teleportOutlet: "teleportOutlet" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: TeleportOutletDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[teleportOutlet]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: TeleportService }]; }, propDecorators: { teleportOutlet: [{
                type: Input
            }] } });

class TeleportDirective {
    constructor(tpl, service) {
        this.tpl = tpl;
        this.service = service;
        this.subscription = null;
    }
    ngOnChanges(changes) {
        if (changes.teleportTo && typeof this.teleportTo === 'string') {
            this.dispose();
            this.subscription = this.service.outlet$(this.teleportTo).subscribe((outlet) => {
                if (outlet) {
                    this.viewRef = outlet.createEmbeddedView(this.tpl);
                }
            });
        }
    }
    ngOnDestroy() {
        this.dispose();
    }
    dispose() {
        this.subscription?.unsubscribe();
        this.subscription = null;
        this.viewRef?.destroy();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: TeleportDirective, deps: [{ token: i0.TemplateRef }, { token: TeleportService }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.3", type: TeleportDirective, selector: "[teleportTo]", inputs: { teleportTo: "teleportTo" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: TeleportDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[teleportTo]',
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }, { type: TeleportService }]; }, propDecorators: { teleportTo: [{
                type: Input
            }] } });
class TeleportModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: TeleportModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.0.3", ngImport: i0, type: TeleportModule, declarations: [TeleportDirective, TeleportOutletDirective], exports: [TeleportDirective, TeleportOutletDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: TeleportModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: TeleportModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [TeleportDirective, TeleportOutletDirective],
                    exports: [TeleportDirective, TeleportOutletDirective],
                }]
        }] });

class CompRef {
    constructor(options) {
        this.options = options;
        if (options.vcr) {
            this.ref = options.vcr.createComponent(options.component, {
                index: options.vcr.length,
                injector: options.injector || options.vcr.injector,
            });
        }
        else {
            this.ref = createComponent(options.component, {
                elementInjector: options.injector,
                environmentInjector: options.environmentInjector,
            });
            options.appRef.attachView(this.ref.hostView);
        }
    }
    setInput(input, value) {
        this.ref.setInput(input, value);
        return this;
    }
    setInputs(inputs) {
        Object.keys(inputs).forEach((input) => {
            this.ref.setInput(input, inputs[input]);
        });
        return this;
    }
    detectChanges() {
        this.ref.hostView.detectChanges();
        return this;
    }
    updateContext(context) {
        this.options.contextSignal?.set(context);
        return this;
    }
    appendTo(container) {
        container.appendChild(this.getElement());
        return this;
    }
    removeFrom(container) {
        container.removeChild(this.getElement());
        return this;
    }
    getRawContent() {
        return this.getElement().outerHTML;
    }
    getElement() {
        return this.ref.location.nativeElement;
    }
    destroy() {
        this.ref.destroy();
        !this.options.vcr && this.options.appRef.detachView(this.ref.hostView);
        this.ref = null;
    }
}

function isTemplateRef(value) {
    return value instanceof TemplateRef;
}
function isComponent(value) {
    return typeof value === 'function';
}
function isString(value) {
    return typeof value === 'string';
}
function getViewRef(value) {
    return value instanceof CompRef ? value.ref.hostView : value.ref;
}

class DynamicViewComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: DynamicViewComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.0.3", type: DynamicViewComponent, selector: "dynamic-view", inputs: { content: "content" }, ngImport: i0, template: ` <div [innerHTML]="content"></div> `, isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: DynamicViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'dynamic-view',
                    template: ` <div [innerHTML]="content"></div> `,
                }]
        }], propDecorators: { content: [{
                type: Input
            }] } });

class TplRef {
    constructor(args) {
        this.args = args;
        if (this.args.vcr) {
            this.ref = this.args.vcr.createEmbeddedView(this.args.tpl, this.args.context || {}, { injector: args.injector });
            this.ref.detectChanges();
        }
        else {
            this.ref = this.args.tpl.createEmbeddedView(this.args.context || {}, args.injector);
            this.ref.detectChanges();
            this.args.appRef.attachView(this.ref);
        }
    }
    detectChanges() {
        this.ref.detectChanges();
        return this;
    }
    getElement() {
        const rootNodes = this.ref.rootNodes;
        if (rootNodes.length === 1 && rootNodes[0] === Node.ELEMENT_NODE) {
            this.element = rootNodes[0];
        }
        else {
            this.element = document.createElement('div');
            this.element.append(...rootNodes);
        }
        return this.element;
    }
    destroy() {
        if (this.ref.rootNodes[0] !== 1) {
            this.element?.parentNode.removeChild(this.element);
            this.element = null;
        }
        if (!this.args.vcr) {
            this.args.appRef.detachView(this.ref);
        }
        this.ref.destroy();
        this.ref = null;
    }
    updateContext(context) {
        this.ref.context = context;
        return this;
    }
}

class StringRef {
    constructor(value) {
        this.value = value;
    }
    getElement() {
        return this.value;
    }
    detectChanges() {
        return this;
    }
    updateContext() {
        return this;
    }
    destroy() { }
}

const VIEW_CONTEXT = new InjectionToken('Component context');
class ViewService {
    constructor() {
        this.injector = inject(Injector);
        this.appRef = inject(ApplicationRef);
        this.environmentInjector = inject(EnvironmentInjector);
    }
    createComponent(component, options = {}) {
        let injector = options.injector ?? this.injector;
        let contextSignal;
        if (options.context) {
            contextSignal = signal(options.context);
            injector = Injector.create({
                providers: [{
                        provide: VIEW_CONTEXT,
                        useValue: contextSignal.asReadonly()
                    }],
                parent: injector
            });
        }
        return new CompRef({
            component,
            vcr: options.vcr,
            injector,
            appRef: this.appRef,
            environmentInjector: options.environmentInjector || this.environmentInjector,
            contextSignal
        });
    }
    createTemplate(tpl, options = {}) {
        return new TplRef({
            vcr: options.vcr,
            appRef: this.appRef,
            tpl,
            context: options.context,
            injector: options.injector
        });
    }
    createView(content, viewOptions = {}) {
        if (isTemplateRef(content)) {
            return this.createTemplate(content, viewOptions);
        }
        else if (isComponent(content)) {
            return this.createComponent(content, viewOptions);
        }
        else if (isString(content)) {
            return new StringRef(content);
        }
        else {
            throw 'Type of content is not supported';
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: ViewService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: ViewService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: ViewService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
function injectViewContext() {
    return inject(VIEW_CONTEXT);
}

class DynamicViewDirective {
    constructor(defaultTpl, vcr, viewService) {
        this.defaultTpl = defaultTpl;
        this.vcr = vcr;
        this.viewService = viewService;
    }
    ngOnInit() {
        this.resolveContentType();
    }
    ngOnChanges(changes) {
        const viewChanged = changes.view && !changes.view.isFirstChange();
        const contextChanged = changes.context && !changes.context.isFirstChange();
        const inputsChanged = changes.inputs && !changes.inputs.isFirstChange();
        if (viewChanged) {
            this.resolveContentType();
        }
        else if (contextChanged) {
            this.viewRef.updateContext(this.context);
        }
        else if (inputsChanged) {
            this.viewRef.setInputs(this.inputs || {});
        }
    }
    resolveContentType() {
        this.viewRef?.destroy();
        if (isString(this.view)) {
            this.viewRef = this.viewService.createComponent(DynamicViewComponent, {
                vcr: this.vcr,
                injector: this.injector,
            });
            this.viewRef.setInput('content', this.view).detectChanges();
        }
        else if (isComponent(this.view)) {
            this.viewRef = this.viewService.createComponent(this.view, {
                vcr: this.vcr,
                injector: this.injector ?? this.vcr.injector,
                context: this.context,
            });
            if (this.inputs) {
                this.viewRef.setInputs(this.inputs);
            }
        }
        else {
            this.viewRef = this.viewService.createView(this.view || this.defaultTpl, {
                vcr: this.vcr,
                injector: this.injector ?? this.vcr.injector,
                context: this.context,
            });
        }
    }
    ngOnDestroy() {
        this.viewRef?.destroy();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: DynamicViewDirective, deps: [{ token: i0.TemplateRef }, { token: i0.ViewContainerRef }, { token: ViewService }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.3", type: DynamicViewDirective, selector: "[dynamicView]", inputs: { view: ["dynamicView", "view"], injector: ["dynamicViewInjector", "injector"], context: ["dynamicViewContext", "context"], inputs: ["dynamicViewInputs", "inputs"] }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: DynamicViewDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[dynamicView]',
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }, { type: i0.ViewContainerRef }, { type: ViewService }]; }, propDecorators: { view: [{
                type: Input,
                args: ['dynamicView']
            }], injector: [{
                type: Input,
                args: ['dynamicViewInjector']
            }], context: [{
                type: Input,
                args: ['dynamicViewContext']
            }], inputs: [{
                type: Input,
                args: ['dynamicViewInputs']
            }] } });
class DynamicViewModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: DynamicViewModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.0.3", ngImport: i0, type: DynamicViewModule, declarations: [DynamicViewDirective, DynamicViewComponent], exports: [DynamicViewDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: DynamicViewModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: DynamicViewModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [DynamicViewDirective, DynamicViewComponent],
                    exports: [DynamicViewDirective],
                }]
        }] });

/*
 * Public API Surface of overview
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CompRef, DynamicViewDirective, DynamicViewModule, StringRef, TeleportDirective, TeleportModule, TeleportOutletDirective, TplRef, ViewService, getViewRef, injectViewContext, isComponent, isString, isTemplateRef };
//# sourceMappingURL=ngneat-overview.mjs.map
