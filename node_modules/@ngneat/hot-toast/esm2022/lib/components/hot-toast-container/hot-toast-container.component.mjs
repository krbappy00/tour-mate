import { Component, ChangeDetectionStrategy, Input, ViewChildren } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Subject } from 'rxjs';
import { filter } from 'rxjs/operators';
import { HotToastComponent } from '../hot-toast/hot-toast.component';
import { HOT_TOAST_MARGIN } from '../../constants';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
export class HotToastContainerComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.toasts = [];
        this.toastRefs = [];
        /** Subject for notifying the user that the toast has been closed. */
        this._onClosed = new Subject();
        this.onClosed$ = this._onClosed.asObservable();
    }
    trackById(index, toast) {
        return toast.id;
    }
    calculateOffset(toastId, position) {
        const visibleToasts = this.toasts.filter((t) => t.visible && t.position === position);
        const index = visibleToasts.findIndex((toast) => toast.id === toastId);
        const offset = index !== -1
            ? visibleToasts
                .slice(...(this.defaultConfig.reverseOrder ? [index + 1] : [0, index]))
                .reduce((acc, t) => acc + (t.height || 0) + HOT_TOAST_MARGIN, 0)
            : 0;
        return offset;
    }
    updateHeight(height, toast) {
        toast.height = height;
        this.cdr.detectChanges();
    }
    addToast(ref) {
        this.toastRefs.push(ref);
        const toast = ref.getToast();
        this.toasts.push(ref.getToast());
        this.cdr.detectChanges();
        return {
            dispose: () => {
                this.closeToast(toast.id);
            },
            updateMessage: (message) => {
                toast.message = message;
                this.updateToasts(toast);
                this.cdr.detectChanges();
            },
            updateToast: (options) => {
                this.updateToasts(toast, options);
                this.cdr.detectChanges();
            },
            afterClosed: this.getAfterClosed(toast),
        };
    }
    closeToast(id) {
        if (id) {
            const comp = this.hotToastComponentList.find((item) => item.toast.id === id);
            if (comp) {
                comp.close();
            }
        }
        else {
            this.hotToastComponentList.forEach((comp) => comp.close());
        }
    }
    beforeClosed(toast) {
        toast.visible = false;
    }
    afterClosed(closeToast) {
        const toastIndex = this.toasts.findIndex((t) => t.id === closeToast.id);
        if (toastIndex > -1) {
            this._onClosed.next(closeToast);
            this.toasts = this.toasts.filter((t) => t.id !== closeToast.id);
            this.toastRefs = this.toastRefs.filter((t) => t.getToast().id !== closeToast.id);
            this.cdr.detectChanges();
        }
    }
    hasToast(id) {
        return this.toasts.findIndex((t) => t.id === id) > -1;
    }
    getAfterClosed(toast) {
        return this.onClosed$.pipe(filter((v) => v.id === toast.id));
    }
    updateToasts(toast, options) {
        this.toasts = this.toasts.map((t) => ({ ...t, ...(t.id === toast.id && { ...toast, ...options }) }));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.1", ngImport: i0, type: HotToastContainerComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.1", type: HotToastContainerComponent, isStandalone: true, selector: "hot-toast-container", inputs: { defaultConfig: "defaultConfig" }, viewQueries: [{ propertyName: "hotToastComponentList", predicate: HotToastComponent, descendants: true }], ngImport: i0, template: "<div style=\"position: fixed; z-index: 9999; top: 0; right: 0; bottom: 0; left: 0; pointer-events: none\">\n  <div style=\"position: relative; height: 100%\">\n    <hot-toast\n      *ngFor=\"let toast of toasts; trackBy: trackById; let i = index\"\n      [toast]=\"toast\"\n      [offset]=\"calculateOffset(toast.id, toast.position)\"\n      [toastRef]=\"toastRefs[i]\"\n      (height)=\"updateHeight($event, toast)\"\n      (beforeClosed)=\"beforeClosed(toast)\"\n      (afterClosed)=\"afterClosed($event)\"\n    ></hot-toast>\n  </div>\n</div>\n", dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: HotToastComponent, selector: "hot-toast", inputs: ["toast", "offset", "defaultConfig", "toastRef"], outputs: ["height", "beforeClosed", "afterClosed"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, preserveWhitespaces: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.1", ngImport: i0, type: HotToastContainerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'hot-toast-container', changeDetection: ChangeDetectionStrategy.OnPush, standalone: true, imports: [CommonModule, HotToastComponent], template: "<div style=\"position: fixed; z-index: 9999; top: 0; right: 0; bottom: 0; left: 0; pointer-events: none\">\n  <div style=\"position: relative; height: 100%\">\n    <hot-toast\n      *ngFor=\"let toast of toasts; trackBy: trackById; let i = index\"\n      [toast]=\"toast\"\n      [offset]=\"calculateOffset(toast.id, toast.position)\"\n      [toastRef]=\"toastRefs[i]\"\n      (height)=\"updateHeight($event, toast)\"\n      (beforeClosed)=\"beforeClosed(toast)\"\n      (afterClosed)=\"afterClosed($event)\"\n    ></hot-toast>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { defaultConfig: [{
                type: Input
            }], hotToastComponentList: [{
                type: ViewChildren,
                args: [HotToastComponent]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG90LXRvYXN0LWNvbnRhaW5lci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ25lYXQvaG90LXRvYXN0L3NyYy9saWIvY29tcG9uZW50cy9ob3QtdG9hc3QtY29udGFpbmVyL2hvdC10b2FzdC1jb250YWluZXIuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmduZWF0L2hvdC10b2FzdC9zcmMvbGliL2NvbXBvbmVudHMvaG90LXRvYXN0LWNvbnRhaW5lci9ob3QtdG9hc3QtY29udGFpbmVyLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsdUJBQXVCLEVBQXFCLEtBQUssRUFBYSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdEgsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFXL0IsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXhDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ3JFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7QUFTbkQsTUFBTSxPQUFPLDBCQUEwQjtJQWFyQyxZQUFvQixHQUFzQjtRQUF0QixRQUFHLEdBQUgsR0FBRyxDQUFtQjtRQVIxQyxXQUFNLEdBQXFCLEVBQUUsQ0FBQztRQUM5QixjQUFTLEdBQWlDLEVBQUUsQ0FBQztRQUU3QyxxRUFBcUU7UUFDN0QsY0FBUyxHQUFHLElBQUksT0FBTyxFQUFpQixDQUFDO1FBRXpDLGNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQVksRUFBRSxDQUFDO0lBRUwsQ0FBQztJQUU5QyxTQUFTLENBQUMsS0FBYSxFQUFF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RUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRU8sWUFBWSxDQUFDLEtBQXFCLEVBQUUsT0FBcUM7UUFDL0UsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEtBQUssQ0FBQyxFQUFFLElBQUksRUFBRSxHQUFHLEtBQUssRUFBRSxHQUFHLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdkcsQ0FBQzs4R0FqR1UsMEJBQTBCO2tHQUExQiwwQkFBMEIscUtBR3ZCLGlCQUFpQixnREM1QmpDLHFpQkFhQSwyQ0RVWSxZQUFZLDRKQUFFLGlCQUFpQjs7MkZBRTlCLDBCQUEwQjtrQkFQdEMsU0FBUzsrQkFDRSxxQkFBcUIsbUJBRWQsdUJBQXVCLENBQUMsTUFBTSxjQUNuQyxJQUFJLFdBQ1AsQ0FBQyxZQUFZLEVBQUUsaUJBQWlCLENBQUM7d0dBR2pDLGFBQWE7c0JBQXJCLEtBQUs7Z0JBRTJCLHFCQUFxQjtzQkFBckQsWUFBWTt1QkFBQyxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgSW5wdXQsIFF1ZXJ5TGlzdCwgVmlld0NoaWxkcmVuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgSG90VG9hc3RDbG9zZSxcbiAgVG9hc3QsXG4gIFRvYXN0Q29uZmlnLFxuICBUb2FzdFBvc2l0aW9uLFxuICBVcGRhdGVUb2FzdE9wdGlvbnMsXG4gIEFkZFRvYXN0UmVmLFxuICBDcmVhdGVIb3RUb2FzdFJlZixcbn0gZnJvbSAnLi4vLi4vaG90LXRvYXN0Lm1vZGVsJztcbmltcG9ydCB7IEhvdFRvYXN0UmVmIH0gZnJvbSAnLi4vLi4vaG90LXRvYXN0LXJlZic7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBDb250ZW50IH0gZnJvbSAnQG5nbmVhdC9vdmVydmlldyc7XG5pbXBvcnQgeyBIb3RUb2FzdENvbXBvbmVudCB9IGZyb20gJy4uL2hvdC10b2FzdC9ob3QtdG9hc3QuY29tcG9uZW50JztcbmltcG9ydCB7IEhPVF9UT0FTVF9NQVJHSU4gfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdob3QtdG9hc3QtY29udGFpbmVyJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2hvdC10b2FzdC1jb250YWluZXIuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgSG90VG9hc3RDb21wb25lbnRdLFxufSlcbmV4cG9ydCBjbGFzcyBIb3RUb2FzdENvbnRhaW5lckNvbXBvbmVudCB7XG4gIEBJbnB1dCgpIGRlZmF1bHRDb25maWc6IFRvYXN0Q29uZmlnO1xuXG4gIEBWaWV3Q2hpbGRyZW4oSG90VG9hc3RDb21wb25lbnQpIGhvdFRvYXN0Q29tcG9uZW50TGlzdDogUXVlcnlMaXN0PEhvdFRvYXN0Q29tcG9uZW50PjtcblxuICB0b2FzdHM6IFRvYXN0PHVua25vd24+W10gPSBbXTtcbiAgdG9hc3RSZWZzOiBDcmVhdGVIb3RUb2FzdFJlZjx1bmtub3duPltdID0gW107XG5cbiAgLyoqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGUgdXNlciB0aGF0IHRoZSB0b2FzdCBoYXMgYmVlbiBjbG9zZWQuICovXG4gIHByaXZhdGUgX29uQ2xvc2VkID0gbmV3IFN1YmplY3Q8SG90VG9hc3RDbG9zZT4oKTtcblxuICBwcml2YXRlIG9uQ2xvc2VkJCA9IHRoaXMuX29uQ2xvc2VkLmFzT2JzZXJ2YWJsZSgpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZikge31cblxuICB0cmFja0J5SWQoaW5kZXg6IG51bWJlciwgdG9hc3Q6IFRvYXN0PHVua25vd24+KSB7XG4gICAgcmV0dXJuIHRvYXN0LmlkO1xuICB9XG5cbiAgY2FsY3VsYXRlT2Zmc2V0KHRvYXN0SWQ6IHN0cmluZywgcG9zaXRpb246IFRvYXN0UG9zaXRpb24pIHtcbiAgICBjb25zdCB2aXNpYmxlVG9hc3RzID0gdGhpcy50b2FzdHMuZmlsdGVyKCh0KSA9PiB0LnZpc2libGUgJiYgdC5wb3NpdGlvbiA9PT0gcG9zaXRpb24pO1xuICAgIGNvbnN0IGluZGV4ID0gdmlzaWJsZVRvYXN0cy5maW5kSW5kZXgoKHRvYXN0KSA9PiB0b2FzdC5pZCA9PT0gdG9hc3RJZCk7XG4gICAgY29uc3Qgb2Zmc2V0ID1cbiAgICAgIGluZGV4ICE9PSAtMVxuICAgICAgICA/IHZpc2libGVUb2FzdHNcbiAgICAgICAgICAgIC5zbGljZSguLi4odGhpcy5kZWZhdWx0Q29uZmlnLnJldmVyc2VPcmRlciA/IFtpbmRleCArIDFdIDogWzAsIGluZGV4XSkpXG4gICAgICAgICAgICAucmVkdWNlKChhY2MsIHQpID0+IGFjYyArICh0LmhlaWdodCB8fCAwKSArIEhPVF9UT0FTVF9NQVJHSU4sIDApXG4gICAgICAgIDogMDtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgdXBkYXRlSGVpZ2h0KGhlaWdodDogbnVtYmVyLCB0b2FzdDogVG9hc3Q8dW5rbm93bj4pIHtcbiAgICB0b2FzdC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICB9XG5cbiAgYWRkVG9hc3Q8RGF0YVR5cGU+KHJlZjogSG90VG9hc3RSZWYpOiBBZGRUb2FzdFJlZjxEYXRhVHlwZT4ge1xuICAgIHRoaXMudG9hc3RSZWZzLnB1c2gocmVmKTtcblxuICAgIGNvbnN0IHRvYXN0ID0gcmVmLmdldFRvYXN0KCk7XG5cbiAgICB0aGlzLnRvYXN0cy5wdXNoKHJlZi5nZXRUb2FzdCgpKTtcblxuICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcblxuICAgIHJldHVybiB7XG4gICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2VUb2FzdCh0b2FzdC5pZCk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlTWVzc2FnZTogKG1lc3NhZ2U6IENvbnRlbnQpID0+IHtcbiAgICAgICAgdG9hc3QubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMudXBkYXRlVG9hc3RzKHRvYXN0KTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZVRvYXN0OiAob3B0aW9uczogVXBkYXRlVG9hc3RPcHRpb25zPERhdGFUeXBlPikgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVRvYXN0cyh0b2FzdCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgIH0sXG4gICAgICBhZnRlckNsb3NlZDogdGhpcy5nZXRBZnRlckNsb3NlZCh0b2FzdCksXG4gICAgfTtcbiAgfVxuXG4gIGNsb3NlVG9hc3QoaWQ/OiBzdHJpbmcpIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGNvbnN0IGNvbXAgPSB0aGlzLmhvdFRvYXN0Q29tcG9uZW50TGlzdC5maW5kKChpdGVtKSA9PiBpdGVtLnRvYXN0LmlkID09PSBpZCk7XG4gICAgICBpZiAoY29tcCkge1xuICAgICAgICBjb21wLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaG90VG9hc3RDb21wb25lbnRMaXN0LmZvckVhY2goKGNvbXApID0+IGNvbXAuY2xvc2UoKSk7XG4gICAgfVxuICB9XG5cbiAgYmVmb3JlQ2xvc2VkKHRvYXN0OiBUb2FzdDx1bmtub3duPikge1xuICAgIHRvYXN0LnZpc2libGUgPSBmYWxzZTtcbiAgfVxuXG4gIGFmdGVyQ2xvc2VkKGNsb3NlVG9hc3Q6IEhvdFRvYXN0Q2xvc2UpIHtcbiAgICBjb25zdCB0b2FzdEluZGV4ID0gdGhpcy50b2FzdHMuZmluZEluZGV4KCh0KSA9PiB0LmlkID09PSBjbG9zZVRvYXN0LmlkKTtcbiAgICBpZiAodG9hc3RJbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLl9vbkNsb3NlZC5uZXh0KGNsb3NlVG9hc3QpO1xuICAgICAgdGhpcy50b2FzdHMgPSB0aGlzLnRvYXN0cy5maWx0ZXIoKHQpID0+IHQuaWQgIT09IGNsb3NlVG9hc3QuaWQpO1xuICAgICAgdGhpcy50b2FzdFJlZnMgPSB0aGlzLnRvYXN0UmVmcy5maWx0ZXIoKHQpID0+IHQuZ2V0VG9hc3QoKS5pZCAhPT0gY2xvc2VUb2FzdC5pZCk7XG4gICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICB9XG5cbiAgaGFzVG9hc3QoaWQ6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLnRvYXN0cy5maW5kSW5kZXgoKHQpID0+IHQuaWQgPT09IGlkKSA+IC0xO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRBZnRlckNsb3NlZCh0b2FzdDogVG9hc3Q8dW5rbm93bj4pIHtcbiAgICByZXR1cm4gdGhpcy5vbkNsb3NlZCQucGlwZShmaWx0ZXIoKHYpID0+IHYuaWQgPT09IHRvYXN0LmlkKSk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVRvYXN0cyh0b2FzdDogVG9hc3Q8dW5rbm93bj4sIG9wdGlvbnM/OiBVcGRhdGVUb2FzdE9wdGlvbnM8dW5rbm93bj4pIHtcbiAgICB0aGlzLnRvYXN0cyA9IHRoaXMudG9hc3RzLm1hcCgodCkgPT4gKHsgLi4udCwgLi4uKHQuaWQgPT09IHRvYXN0LmlkICYmIHsgLi4udG9hc3QsIC4uLm9wdGlvbnMgfSkgfSkpO1xuICB9XG59XG4iLCI8ZGl2IHN0eWxlPVwicG9zaXRpb246IGZpeGVkOyB6LWluZGV4OiA5OTk5OyB0b3A6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IGxlZnQ6IDA7IHBvaW50ZXItZXZlbnRzOiBub25lXCI+XG4gIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogcmVsYXRpdmU7IGhlaWdodDogMTAwJVwiPlxuICAgIDxob3QtdG9hc3RcbiAgICAgICpuZ0Zvcj1cImxldCB0b2FzdCBvZiB0b2FzdHM7IHRyYWNrQnk6IHRyYWNrQnlJZDsgbGV0IGkgPSBpbmRleFwiXG4gICAgICBbdG9hc3RdPVwidG9hc3RcIlxuICAgICAgW29mZnNldF09XCJjYWxjdWxhdGVPZmZzZXQodG9hc3QuaWQsIHRvYXN0LnBvc2l0aW9uKVwiXG4gICAgICBbdG9hc3RSZWZdPVwidG9hc3RSZWZzW2ldXCJcbiAgICAgIChoZWlnaHQpPVwidXBkYXRlSGVpZ2h0KCRldmVudCwgdG9hc3QpXCJcbiAgICAgIChiZWZvcmVDbG9zZWQpPVwiYmVmb3JlQ2xvc2VkKHRvYXN0KVwiXG4gICAgICAoYWZ0ZXJDbG9zZWQpPVwiYWZ0ZXJDbG9zZWQoJGV2ZW50KVwiXG4gICAgPjwvaG90LXRvYXN0PlxuICA8L2Rpdj5cbjwvZGl2PlxuIl19